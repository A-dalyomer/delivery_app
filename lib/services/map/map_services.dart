import 'package:deliveyapp/business_logic/utils/enums.dart';import 'package:flutter/foundation.dart';import 'package:flutter/services.dart';import 'package:flutter_polyline_points/flutter_polyline_points.dart'    hide TravelMode;import 'package:georouter/georouter.dart';import 'package:google_maps_flutter/google_maps_flutter.dart';import 'package:location_distance_calculator/location_distance_calculator.dart';/// handles the map related services/// currently provides the ability to load the route data with two different ways/// first one is using the free OSRM api/// the second one uses the paid google api/// the active loaded way can be changed with the provided [RouteApiMode]class MapServices {  /// calls the associated route loading choice as of the [RouteApiMode] value  Future<List<LatLng>> getRoute({    required RouteApiMode apiMode,    required List<LatLng> points,  }) async {    switch (apiMode) {      case RouteApiMode.osrm:        return _getRoutePolyOSRM(points);      case RouteApiMode.google:        return _getRoutePolyGoogleAPI(destinationPoints: points);    }  }  /// loads the route of the provided location [points] from the free OSRM API  Future<List<LatLng>> _getRoutePolyOSRM(List<LatLng> points) async {    final geoRouter = GeoRouter(mode: TravelMode.driving);    final List<PolylinePoint> coordinates = points        .map((e) => PolylinePoint(latitude: e.latitude, longitude: e.longitude))        .toList();    try {      final directions =          await geoRouter.getDirectionsBetweenPoints(coordinates);      if (kDebugMode) {        print('got routes');        print(directions);      }      return directions.map((e) => LatLng(e.latitude, e.longitude)).toList();    } on GeoRouterException {      return [];    }  }  /// loads the route of the provided location [destinationPoints] from the paid Google API  Future<List<LatLng>> _getRoutePolyGoogleAPI({    required List<LatLng> destinationPoints,  }) async {    List<PolylineWayPoint> stops = [];    List<LatLng> polylineCoordinates = [];    PolylinePoints polylinePoints = PolylinePoints();    /// determine the stops across the route    if (destinationPoints.length > 1) {      for (int i = 0; i < (destinationPoints.length - 1); i++) {        stops.add(          PolylineWayPoint(            location:                "${destinationPoints[i].latitude.toString()},${destinationPoints[i].longitude.toString()}",            stopOver: true,          ),        );      }    }    /// request the route data from the API with the provided parameters    PolylineResult result = await polylinePoints.getRouteBetweenCoordinates(      "AIzaSyB6NSEN5ihOGZlMEi7x4AzYLUglMc-ROPY",      PointLatLng(          destinationPoints.first.latitude, destinationPoints.first.longitude),      PointLatLng(          destinationPoints.last.latitude, destinationPoints.last.longitude),      wayPoints: stops,    );    /// Handle the resulted data    if (kDebugMode) {      print('poly points: ${result.points}');    }    if (result.points.isNotEmpty) {      for (var point in result.points) {        polylineCoordinates.add(LatLng(point.latitude, point.longitude));      }    }    return polylineCoordinates;  }  /// Calculates the resulted route distance in meters  /// best used as the last step after generating the route for precise result  Future<double> calculateTotalDistance(List<LatLng> route) async {    try {      double distance = 0;      for (int i = 0; i < route.length - 1; i++) {        distance += await LocationDistanceCalculator().distanceBetween(          route[i].latitude,          route[i].longitude,          route[i + 1].latitude,          route[i + 1].longitude,        );      }      return distance;    } on PlatformException {      return 0;    }  }}